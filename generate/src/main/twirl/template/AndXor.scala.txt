@(tpes: List[List[String]])

import scalaz.{Apply, Monoid}

abstract class ComposeAndXor[F[_], Cop, Prod] {
  def mkChoose[B](f: B => Cop)(implicit d: Decidable[F]): F[B]
  def mkAlt[B](f: Cop => B)(implicit a: Alt[F]): F[B]
  def mkDivide[B](f: B => Prod)(implicit a: Divide[F]): F[B]
  def mkApply[B](f: Prod => B)(implicit a: Apply[F]): F[B]

  def choose(implicit d: Decidable[F]): F[Cop] = mkChoose(identity _)
  def alt(implicit a: Alt[F]): F[Cop] = mkAlt(identity _)
  def divide(implicit d: Divide[F]): F[Prod] = mkDivide(identity _)
  def apply(implicit a: Apply[F]): F[Prod] = mkApply(identity _)
}

trait AndXorEvidence[Cop, Prod] {
  implicit val injEv: Inj[Cop, Cop]
  implicit def liftEv(implicit M: Monoid[Prod]): Inj[Prod, Prod]
  implicit def injCopToProdEv(implicit M: Monoid[Prod]): Inj[Prod, Cop]

  implicit def injProdToVecCopEvHelper[A](implicit i: Inj[Cop, A]): Inj[Vector[Cop], A] = Inj.instance(a => Vector(i(a)))
  implicit val injProdToVecCopEv: Inj[Vector[Cop], Prod]
}

trait AndXor {
  type Cop
  type Prod
  def inj[A](a: A)(implicit inj: Inj[Cop, A]): Cop = inj(a)
  def lift[A](a: A)(implicit inj: Inj[Prod, A]): Prod = inj(a)
  val evidence: AndXorEvidence[Cop, Prod]
}

object AndXor {
  @tpes.map(template.txt.Build(_)).mkString("\n")
}
