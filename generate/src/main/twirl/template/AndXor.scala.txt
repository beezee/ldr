@import andxor.syntax._

@()

import scalaz.{Apply, Monoid}
import scalaz.Id.Id

trait AndXorEvidence[Cop[_[_]], Prod[_[_]]] {
  implicit def injEv[F[_]](implicit d: DerivingCop[Cop, F, Inj[Cop[F], ?]]): Inj[Cop[F], Cop[F]]
  implicit def liftEv[F[_]](implicit M: Monoid[Prod[F]], d: DerivingProd[Prod, F, Inj[Prod[F], ?]]): Inj[Prod[F], Prod[F]]
}

trait AndXor { self =>
  type Cop[F[_]]
  type Prod[F[_]]

  val evidence: AndXorEvidence[Cop, Prod]

  def fix[F[_]]: AndXorFixed[F] = new AndXorFixed[F] {
    type AXO = self.type
    val axo: self.type = self
    val evidence: AndXorEvidence[self.Cop, self.Prod] = self.evidence
  }

  def inj[F[_], A](a: A)(implicit inj: Inj[Cop[F], A]): Cop[F] = inj(a)
  def injId[A](a: A)(implicit inj: Inj[Cop[Id], Id[A]]): Cop[Id] = inj(a)
  def lift[F[_], A](a: A)(implicit inj: Inj[Prod[F], A]): Prod[F] = inj(a)
  def liftId[A](a: A)(implicit inj: Inj[Prod[Id], Id[A]]): Prod[Id] = inj(a)
  def extractC[F[_], B](c: Cop[F])(implicit inj: Inj[Option[F[B]], Cop[F]]): Option[F[B]] = inj(c)
  def extractP[F[_], B](p: Prod[F])(implicit inj: Inj[F[B], Prod[F]]): F[B] = inj(p)

  def choose[TC[_], F[_]](implicit x: Decidable[TC], d: DerivingCop[Cop, F, TC]): TC[Cop[F]] = d.choose
  def alt[TC[_], F[_]](implicit x: Alt[TC], d: DerivingCop[Cop, F, TC]): TC[Cop[F]] = d.alt
  def divide[TC[_], F[_]](implicit x: Divide[TC], d: DerivingProd[Prod, F, TC]): TC[Prod[F]] = d.divide
  def apply[TC[_], F[_]](implicit x: Apply[TC], d: DerivingProd[Prod, F, TC]): TC[Prod[F]] = d.apply

  def choose[TC[_]](implicit x: Decidable[TC], d: DerivingCop[Cop, Id, TC], _d: DummyImplicit): TC[Cop[Id]] = d.choose
  def alt[TC[_]](implicit x: Alt[TC], d: DerivingCop[Cop, Id, TC], _d: DummyImplicit): TC[Cop[Id]] = d.alt
  def divide[TC[_]](implicit x: Divide[TC], d: DerivingProd[Prod, Id, TC], _d: DummyImplicit): TC[Prod[Id]] = d.divide
  def apply[TC[_]](implicit x: Apply[TC], d: DerivingProd[Prod, Id, TC], _d: DummyImplicit): TC[Prod[Id]] = d.apply
}

trait AndXorFixed[F[_]] {
  type AXO <: AndXor
  val axo: AXO

  type Cop = axo.Cop[F]
  type Prod = axo.Prod[F]

  val evidence: AndXorEvidence[axo.Cop, axo.Prod]

  def inj[A](a: A)(implicit inj: Inj[Cop, A]): Cop = inj(a)
  def lift[A](a: A)(implicit inj: Inj[Prod, A]): Prod = inj(a)
  def extractC[B](c: Cop)(implicit inj: Inj[Option[F[B]], Cop]): Option[F[B]] = inj(c)
  def extractP[B](p: Prod)(implicit inj: Inj[F[B], Prod]): F[B] = inj(p)

  def choose[TC[_]](implicit x: Decidable[TC], d: DerivingCop[axo.Cop, F, TC]): TC[Cop] = d.choose
  def alt[TC[_]](implicit x: Alt[TC], d: DerivingCop[axo.Cop, F, TC]): TC[Cop] = d.alt
  def divide[TC[_]](implicit x: Divide[TC], d: DerivingProd[axo.Prod, F, TC]): TC[Prod] = d.divide
  def apply[TC[_]](implicit x: Apply[TC], d: DerivingProd[axo.Prod, F, TC]): TC[Prod] = d.apply
}

trait AndXorLift[A] { type AXO <: AndXor }
trait AndXorLiftLP {
  implicit def lp[A]: AndXorLift.Aux[A, AndXor1[A]] = new AndXorLift[A] { type AXO = AndXor1[A] }
}
object AndXorLift extends AndXorLiftLP {
  type Aux[A, AXO0] = AndXorLift[A] { type AXO = AXO0 }

  implicit def hp[A <: AndXor]: AndXorLift.Aux[A, A] = new AndXorLift[A] { type AXO = A }
}

object AndXor {
  def build[A]: AndXor1[A] = AndXor1[A]
  @mkTpeList(2, 22).map(template.txt.Build(_).toString.trim).mkString("\n")
}
