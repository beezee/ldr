@import andxor.syntax._

@(tpeLists: List[List[String]])

import scalaz.Apply
import scalaz.Id.Id
import scalaz.Isomorphism.<=>

object derivation {
  @tpeLists.map { tpes =>
  trait Derivation@{tpes.length}P[F[_], @{tpes.rank2TpeParams}] {
    val axo = AndXor@{tpes.length}[@{tpes.tpeParams}]

    def deriveCovariant[TC[_], A](iso: A <=> axo.Prod[F])(implicit F: Apply[TC], d: DerivingProd[axo.Prod, F, TC]): TC[A] =
      F.map(axo.apply[TC, F])(iso.from(_))

    def deriveContravariant[TC[_], A](iso: A <=> axo.Prod[F])(implicit F: Divide[TC], d: DerivingProd[axo.Prod, F, TC]): TC[A] =
      F.contramap(axo.divide[TC, F])(iso.to(_))
  }
  }

  trait LPSyntax {
    @tpeLists.map { tpes =>
    implicit class Derivation@{tpes.length}POps[A, F[_], @{tpes.rank2TpeParams}](iso: A <=> AndXor@{tpes.length}[@{tpes.tpeParams}]#Prod[F]) {
      val derive = new Derivation@{tpes.length}P[F, @{tpes.tpeParams}] {}

      def deriveCovariant[TC[_]](implicit F: Apply[TC], d: DerivingProd[derive.axo.Prod, F, TC]): TC[A] =
        derive.deriveCovariant[TC, A](iso)

      def deriveContravariant[TC[_]](implicit F: Divide[TC], d: DerivingProd[derive.axo.Prod, F, TC]): TC[A] =
        derive.deriveContravariant[TC, A](iso)
    }
    }
  }

  object syntax extends LPSyntax {
    @tpeLists.map { tpes =>
    implicit class Derivation@{tpes.length}POps[A, @{tpes.rank2TpeParams}](iso: A <=> AndXor@{tpes.length}[@{tpes.tpeParams}]#Prod[Id]) {
      val derive = new Derivation@{tpes.length}P[Id, @{tpes.tpeParams}] {}

      def deriveCovariant[TC[_]](implicit F: Apply[TC], d: DerivingProd[derive.axo.Prod, Id, TC]): TC[A] =
        derive.deriveCovariant[TC, A](iso)

      def deriveContravariant[TC[_]](implicit F: Divide[TC], d: DerivingProd[derive.axo.Prod, Id, TC]): TC[A] =
        derive.deriveContravariant[TC, A](iso)
    }
    }
  }
}
