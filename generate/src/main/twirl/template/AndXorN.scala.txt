@import andxor.syntax._
@import scalaz.syntax.id._

@(tpes: List[String])

import andxor.tuple._
import scala.language.higherKinds
import scalaz.{Apply, Functor, PlusEmpty, Monoid, \/, -\/, \/-, ~>}
import scalaz.Id.Id

trait AndXor@{tpes.length}[@{tpes.tpeParams}] extends AndXor {
  case class ProdT[F[_]](run: @{tpes.prodK("F")})
  object ProdT {
    @{tpes.zipper(template.txt.Lift(_)).mkString("\n")}
  }

  type Prod[F[_]] = ProdT[F]

  case class CopT[F[_]](run: @{tpes.djK("F")})
  object CopT {
    @{tpes.zipper(template.txt.Inj(_)).mkString("\n")}
  }

  type Cop[F[_]] = CopT[F]

  def combine[F[_], G[_]](implicit @{tpes.paramSig(List("G", "F"), "a")}): ComposeAndXor[F, G, Cop, Prod] =
    new ComposeAndXor[F, G, Cop, Prod] {
      def mkChoose[B](f: B => Cop[F])(implicit d: Decidable[G]): G[B] =
        Combine.choose@{tpes.length}(@{tpes.params("a")})(f(_).run)

      def mkAlt[B](f: Cop[F] => B)(implicit a: Alt[G]): G[B] =
        Combine.altly@{tpes.length}(@{tpes.params("a")})(x => f(CopT(x)))

      def mkDivide[B](f: B => Prod[F])(implicit d: Divide[G]): G[B] =
        Combine.divide@{tpes.length}(@{tpes.params("a")})(f(_).run)

      def mkApply[B](f: Prod[F] => B)(implicit a: Apply[G]): G[B] =
        Combine.apply@{tpes.length}(@{tpes.params("a")}) {
          case @{tpes.paramList("i").mkTuple} =>
            f(ProdT(@{tpes.paramList("i").mkTuple}))
        }
    }

  def injEv[F[_]] = combine[F, Inj.Aux[Cop[F]]#Out].choose
  def liftEv[F[_]](implicit M: Monoid[Prod[F]]): Inj[Prod[F], Prod[F]] = combine[F, Inj.Aux[Prod[F]]#Out].divide

  def transformP[F[_], G[_]](nt: (F ~> G)):
  AndXor@{tpes.length}[@{tpes.tpeParams}]#Prod[F] => AndXor@{tpes.length}[@{tpes.tpeParams}]#Prod[G] =
    (p: AndXor@{tpes.length}[@{tpes.tpeParams}]#Prod[F]) => {
      val pr = p.run
      ProdT[G](@{tpes.zipWithIndex.map(x => s"nt(pr.${tpes.tupleAccess(x._2 + 1)})").mkTuple})
    }

  def transformC[F[_], G[_]](nt: (F ~> G)):
  AndXor@{tpes.length}[@{tpes.tpeParams}]#Cop[F] => AndXor@{tpes.length}[@{tpes.tpeParams}]#Cop[G] =
    (p: AndXor@{tpes.length}[@{tpes.tpeParams}]#Cop[F]) =>
      CopT[G](p.run@{tpes.tail.foldRight("nt(_)")((_, a) => s"_.bimap(nt(_), ${a})").tail})

  @*@{tpes.zipper(template.txt.Subst(_)).mkString("\n")}*@

  // format: off
  def sequenceP[F[_]](prod: Prod[F])(implicit A: Apply[F]): F[Prod[Id]] = {
    val p = prod.run
    A.map(@{tpes.paramList("p.t", 1).tail.foldLeft(
      s"""\n    A.map(p.t1)(${tpes.paramList("i").zip(tpes).map(t => s"(${t._1}: ${t._2})").mkString(" => ")} =>\n      ${tpes.paramList("i").mkTuple})""")(
        (a, e) => s"\n    A.ap($e)($a)")})(ProdT[Id](_))
  }

  def sequenceC[F[_]](cop: Cop[F])(implicit FF: Functor[F]): F[Cop[Id]] =
    cop.run match {
      @{tpes.zipper(SequenceC(_)).mkString("      ").trim}
    }

  def extractC[F[_], B](c: Cop[F])(implicit inj: Inj[Option[B], Cop[F]]): Option[B] = inj(c)

  def extractP[F[_], B](p: Prod[F])(implicit inj: Inj[B, Prod[F]]): B = inj(p)

  def foldMap[F[_], C](p: Prod[F])(map: Cop[F] => C)(implicit M: Monoid[C]): C = {
    val pr = p.run
    @{tpes.zipWithIndex.map(t => s"map(CopT.inja${t._2}(pr.${tpes.tupleAccess(t._2 + 1)}))") |>
      (ps => ps.init.foldRight(ps.last)((p, acc) => s"M.append($p, $acc)"))}
  }

  def foldMapId[F[_], C](p: Prod[F])(map: Cop[Id] => C)(
      implicit O: Ordering[Cop[Id]], M: Monoid[C], PE: PlusEmpty[F], U: Uncons[F]): C = {
    import scala.collection.mutable.{PriorityQueue => PQ}
    def uncons(p: Prod[F]): (List[Cop[Id]], Prod[F]) = {
      val pr = p.run
      @{1.to(tpes.length).toList.map(i => s"val ht$i = U(pr.${tpes.tupleAccess(i)})").mkString("\n      ")}
      (List(@{tpes.zip(Stream.from(1)).map(t => s"ht${t._2}._1.map(inj(_: Id[${t._1}]))").mkString(", ")}).flatten,
        ProdT[F](@{1.to(tpes.length).toList.map(i => s"ht$i._2").mkTuple}))
    }
    @@scala.annotation.tailrec
    def go(prod: Prod[F], q: PQ[Cop[Id]], out: C): C =
      (prod.run.==(@{tpes.map(t => s"PE.empty[${t}]").mkTuple})) match {
        case true =>
          q.foldLeft(out)((acc, el) => M.append(acc, map(el)))
        case false => q.isEmpty match @{s"""{
          case true => {
            val (hs, ts) = uncons(prod)
            q ++= hs
            go(ts, q, out)
          }
          case false => q.dequeue.run match {
            ${tpes.zipper(FoldMap(_)).mkString("").dropWhile(_ == ' ')}
          }
        }"""}
      }
    val Q = new PQ[Cop[Id]]()(O)
    val (hs, ts) = uncons(p)
    Q ++= hs
    go(ts, Q, M.zero)
  }
  // format: on
}

object AndXor@{tpes.length} {
  def apply[@{tpes.tpeParams}]: AndXor@{tpes.length}[@{tpes.tpeParams}] =
    new AndXor@{tpes.length}[@{tpes.tpeParams}] {}
}
