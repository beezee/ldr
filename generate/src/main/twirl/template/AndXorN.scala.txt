@import andxor.syntax._

@(tpes: List[String])

@if(tpes.length > 1){import andxor.tuple._}
import andxor.types.{@{tpes.copName}, @{tpes.prodName}}
import scalaz.{Apply, Functor, PlusEmpty, Monoid@{tpes.foldLen01("")(", \\/, -\\/, \\/-")}, ~>}
import scalaz.Id.Id

trait AndXorK@{tpes.length}[F[_], @{tpes.tpeParams}] extends AndXor {
  type Prod = @{tpes.prodTpe}
  object Prod { def apply(p: @{tpes.prodK("F")}): Prod = @{tpes.prodTpe}(p) }

  type Cop = @{tpes.copTpe}
  object Cop { def apply(c: @{tpes.djK("F")}): Cop = @{tpes.copTpe}(c) }

  val AndXorF = AndXorF@{tpes.length}[@{tpes.tpeParams}]
  type AndXor[G[_]] = AndXorF.Repr[G]

  def combine[G[_]](implicit @{tpes.foldLen0("a0: G[F[Unit]]")(tpes.paramSig(List("G", "F"), "a"))}): ComposeAndXor[G, Cop, Prod] =
    new ComposeAndXor[G, Cop, Prod] {
      def mkChoose[B](f: B => Cop)(implicit d: Decidable[G]): G[B] =
        @tpes.foldLen01("d.contramap(a0)(f(_).run)")(s"Combine.choose${tpes.length}(${tpes.params("a")})(f(_).run)")

      def mkAlt[B](f: Cop => B)(implicit a: Alt[G]): G[B] =
        @tpes.foldLen01("a.map(a0)(x => f(Cop(x)))")(s"Combine.altly${tpes.length}(${tpes.params("a")})(x => f(Cop(x)))")

      def mkDivide[B](f: B => Prod)(implicit d: Divide[G]): G[B] =
        @tpes.foldLen01("d.contramap(a0)(f(_).run)")(s"Combine.divide${tpes.length}(${tpes.params("a")})(f(_).run)")

      def mkApply[B](f: Prod => B)(implicit a: Apply[G]): G[B] =
        @tpes.foldLen01[Any]("a.map(a0)(x => f(Prod(x)))") {
        Combine.apply@{tpes.length}(@{tpes.params("a")}) {
          case @{tpes.paramList("i").mkTuple} =>
            f(Prod(@{tpes.paramList("i").mkTuple}))
        }
        }
  }

  val injEv = combine[Inj[Cop, ?]].choose
  def liftEv(implicit M: Monoid[Prod]): Inj[Prod, Prod] = combine[Inj[Prod, ?]].divide

  def transformP[G[_]](nt: (F ~> G)):
  AndXorK@{tpes.length}[F, @{tpes.tpeParams}]#Prod => AndXorK@{tpes.length}[G, @{tpes.tpeParams}]#Prod =
    (p: AndXorK@{tpes.length}[F, @{tpes.tpeParams}]#Prod) => {
      val pr = p.run
      @{tpes.prodTpeF("G")}(@{tpes.zipWithIndex.map(x => s"nt(pr${tpes.tupleAccess(x._2 + 1)})").mkTuple})
    }

  def transformC[G[_]](nt: (F ~> G)):
  AndXorK@{tpes.length}[F, @{tpes.tpeParams}]#Cop => AndXorK@{tpes.length}[G, @{tpes.tpeParams}]#Cop =
    (p: AndXorK@{tpes.length}[F, @{tpes.tpeParams}]#Cop) =>
      @{tpes.copTpeF("G")}(@tpes.foldLen01[Any]("nt(p.run)") {
        p.run@{tpes.drop(1).foldRight("nt(_)")((_, a) => s"_.bimap(nt(_), ${a})").tail}
      })

  @{tpes.zipper(template.txt.Subst(_)).mkString("\n")}

  // format: off
  def sequenceP(prod: Prod)(implicit A: Apply[F]): F[@{tpes.prodTpeF("Id")}] = {
    val p = prod.run
    A.map(@{tpes.paramListF(i => s"p${tpes.tupleAccess(i)}", 1).tail.foldLeft(
      s"""\n    A.map(${tpes.foldLen01("p")(s"p${tpes.tupleAccess(1)}")})(${tpes.paramList("i").zip(tpes).map(t => s"(${t._1}: ${t._2})").mkString(" => ")} =>\n      ${tpes.paramList("i").mkTuple})""")(
        (a, e) => s"\n    A.ap($e)($a)")})(@{tpes.prodTpeF("Id")}(_))
  }

  def sequenceC(cop: Cop)(implicit FF: Functor[F]): F[@{tpes.copTpeF("Id")}] =
    cop.run match {
      @{tpes.zipper(SequenceC(_)).mkString("      ").trim}
    }

  def extractC[B](c: Cop)(implicit inj: Inj[Option[B], Cop]): Option[B] = inj(c)

  def extractP[B](p: Prod)(implicit inj: Inj[B, Prod]): B = inj(p)

  def foldMap[G[_], C](p: AndXor[G]#Prod)(map: AndXor[Id]#Cop => C)(
      implicit O: Ordering[@{tpes.copTpeF("Id")}], M: Monoid[C], PE: PlusEmpty[G], U: Uncons[G]): C = {
    import scala.collection.mutable.{PriorityQueue => PQ}

    val TG = AndXorF[G]
    val TI = AndXorF[Id]

    def uncons(p: TG.Prod): (List[TI.Cop], TG.Prod) = {
      val pr = p.run
      @{1.to(tpes.length).toList.map(i => s"val ht$i = U(pr${tpes.tupleAccess(i)})").mkString("\n      ")}
      (List(@{tpes.zip(Stream.from(1)).map(t => s"ht${t._2}._1.map(TI.inj(_: Id[${t._1}]))").mkString(", ")}).flatten,
        TG.Prod(@{1.to(tpes.length).toList.map(i => s"ht$i._2").mkTuple}))
    }
    @@scala.annotation.tailrec
    def go(prod: TG.Prod, q: PQ[TI.Cop], out: C): C =
      (prod.run.==(@{tpes.map(t => s"PE.empty[${t}]").mkTuple})) match {
        case true =>
          q.foldLeft(out)((acc, el) => M.append(acc, map(el)))
        case false => q.isEmpty match @{s"""{
          case true => {
            val (hs, ts) = uncons(prod)
            q ++= hs
            go(ts, q, out)
          }
          case false => q.dequeue.run match {
            ${tpes.zipper(FoldMap(_)).mkString("").dropWhile(_ == ' ')}
          }
        }"""}
      }
    val Q = new PQ[TI.Cop]()(O)
    val (hs, ts) = uncons(p)
    Q ++= hs
    go(ts, Q, M.zero)
  }
  // format: on
}

object AndXorK@{tpes.length} {

  def apply[F[_], @{tpes.tpeParams}]: AndXorK@{tpes.length}[F, @{tpes.tpeParams}] =
    new AndXorK@{tpes.length}[F, @{tpes.tpeParams}] {}
}

trait AndXorF@{tpes.length}[@{tpes.tpeParams}] {
  type Repr[F[_]] = AndXorK@{tpes.length}[F, @{tpes.tpeParams}]
  def apply[F[_]]: Repr[F] =
    new AndXorK@{tpes.length}[F, @{tpes.tpeParams}] {}
}

object AndXorF@{tpes.length} {
  def apply[@{tpes.tpeParams}]: AndXorF@{tpes.length}[@{tpes.tpeParams}] =
    new AndXorF@{tpes.length}[@{tpes.tpeParams}] {}
}

trait AndXor@{tpes.length}[@{tpes.tpeParams}] extends
AndXorK@{tpes.length}[Id, @{tpes.tpeParams}]

object AndXor@{tpes.length} {
  def apply[@{tpes.tpeParams}]: AndXor@{tpes.length}[@{tpes.tpeParams}] =
    new AndXor@{tpes.length}[@{tpes.tpeParams}] {}
}
