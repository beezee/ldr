@import andxor.syntax._
@import scalaz.Zipper

@(z: Zipper[String])
            case @{z.lefts.foldRight(Some(z).filterNot(_.atEnd).fold(z.toList.foldLen01("_")("x"))(_ => "-\\/(x)"))((_, a) => s"\\/-(${a})")} =>
              val (h, t) = @z.toList.foldLen01(s"U(p.run)")(s"${z.toList.foldMapName(z.index)}.unconsOne(p${z.toList.prodAccess(z.index + 1)}, x)")
              (h.map(v => @{z.toList.copTpeF("G")}(@{z.djVal("v")})), @{z.toList.prodTpe}(@{
                1.to(z.length).toList.map(i => s"p${z.toList.prodAccess(i)}").updated(z.index, "t").mkTuple}))
