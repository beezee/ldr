@import andxor.syntax._
@import scalaz.Zipper
@import scalaz.syntax.std.boolean._

@(z: Zipper[String], isId: Boolean)

@tpes = @{ z.toList }
@F = @{ isId.fold("Id", "F") }
@tp = @{ isId.fold("", s"F[_], ") }
@wrappedTpe = @{ z.toList.copTpes(F)(z.index) }

    implicit def prisma@{z.index}@{F}[@{tp}@{tpes.axoTpeParams}]: Prism[@{tpes.copTpeF(F)}, @{wrappedTpe}] =@if(isId) { prisma@{z.index}F[Id, @{tpes.tpeParams}] } else { new Prism[@{tpes.copTpeF(F)}, @{wrappedTpe}] {
        def getOption(c: @{tpes.copTpeF(F)}): Option[@{wrappedTpe}] = @{tpes.foldLen01("Some(c.run)")(s"""c.run match {
          case ${z.djVal("x")} => Some(x)
          case _ => None
        }""")}
        def reverseGet(x: @{wrappedTpe}): @{tpes.copTpeF(F)} = @{tpes.copTpeF(F)}(@z.djVal("x"))
      } }

    implicit def inja@{z.index}@{F}[@{tp}@{tpes.axoTpeParams}]: Inj[@{tpes.copTpeF(F)}, @{wrappedTpe}] =@if(isId) { inja@{z.index}F[Id, @{tpes.tpeParams}] } else { Inj.instance(prisma@{z.index}@{F}.reverseGet(_)) }

    implicit def inja@{z.index}@{F}Inverse[F[_], @{tpes.axoTpeParams}]: Inj[Option[@{wrappedTpe}], @{tpes.copTpeF(F)}] =@if(isId) { inja@{z.index}FInverse[Id, @{tpes.tpeParams}] } else { Inj.instance(prisma@{z.index}@{F}.getOption(_)) }
