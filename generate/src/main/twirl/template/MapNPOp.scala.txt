@import andxor.syntax._
@import scalaz.Zipper
@import scalaz.syntax.std.boolean._

@(z: Zipper[String], prod: Boolean)
@tpes = @{ z.toList }
@mod = @{ tpes.updated(z.index, "B") }
@B = @{ prod.fold(mod.toList.rank2TpeParamsList(z.index), mod.toList(z.index)) }
@origT = @{ tpes.prodTpes()(z.index) }
@modT = @{ mod.prodTpes()(z.index) }

  def map@{z.index + 1}[@{B}](f: @{prod.fold(origT, z.focus)} => @{prod.fold(modT, "B")}): @{prod.fold(mod.prodTpe, mod.prod)} =
    @z.wrapProdOrTuple(prod)(s"mapN.map${z.index + 1}(${prod.fold("run", "p")})(f)")

  def mapAt[@{B}](f: @{prod.fold(origT, z.focus)} => @{prod.fold(modT, "B")})@{Some(z.lefts.toList).filter(_.nonEmpty).fold("")(
    _ => z.dummyImpl(prod))}: @{prod.fold((_: LS).prodTpe, (_: LS).prod)(z.modify(_ => "B").toList)} =
    @z.wrapProdOrTuple(prod)(s"mapN.map${prod.fold("At(f)(run)", s"${z.index + 1}(p)(f)")}")
