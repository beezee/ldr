@import andxor.syntax._
@import scalaz.Zipper
@import scalaz.syntax.std.boolean._

@(z: Zipper[String], isId: Boolean)

@prodAccesses(l: List[String], i: Int) = @{ l.zip(Stream.from(i)).map(t => s"t${z.toList.prodAccess(t._2 + 1)}") }
@tpes = @{ z.toList }
@F = @{ isId.fold("Id", "F") }
@tp = @{ isId.fold("", s"F[_], ") }
@wrappedTpe = @{ z.toList.prodTpes(Some(F))(z.index) }
@monoid(others: Boolean) = @{
  tpes.foldLen01("")(others.fold[String => String](x => s", $x", x => s"(implicit $x)")(s" M: Monoid[${tpes.prodTpeF(F)}]"))
}

    implicit def lifta@{z.index}@{F}[@{tp}@{tpes.rank2TpeParams}]@{monoid(false)}: Inj[@tpes.prodTpeF(F), @{wrappedTpe}] =
      @if(isId) {
        lifta@{z.index}F[Id, @{tpes.tpeParams}]
      } else { {
        @tpes.foldLen01("")("val t = M.zero\n      ")Inj.instance(x => @{tpes.prodTpeF(F)}(@{((prodAccesses(z.lefts.toList, 0) :+ "x") ++
          prodAccesses(z.rights.toList, z.lefts.toList.length + 1)).mkTuple}))
      } }

    implicit def lifta@{z.index}@{F}Inverse[@{tp}@{tpes.rank2TpeParams}]: Inj[@{wrappedTpe}, @tpes.prodTpeF(F)] =
      @if(isId) { lifta@{z.index}FInverse[Id, @{tpes.tpeParams}] } else { Inj.instance(_@{z.toList.prodAccess(z.index + 1)}) }

    @if(z.toList.length > 1) {
      implicit def liftViaA@{z.index}@{F}[@{tp}@{tpes.rank2TpeParams}, A](implicit i: Inj[@{wrappedTpe}, A]@{monoid(true)}): Inj[@{tpes.prodTpeF(F)}, A] =
        @if(isId) { liftViaA@{z.index}F[Id, @{tpes.tpeParams}, A] } else { Inj.instance((i.apply _).andThen(lifta@{z.index}@{F}[@{F}, @{tpes.tpeParams}].apply _)) }

      implicit def liftViaA@{z.index}@{F}Inverse[@{tp}@{tpes.rank2TpeParams}, A](implicit i: Inj[A, @{wrappedTpe}]): Inj[A, @{tpes.prodTpeF(F)}] =
        @if(isId) { liftViaA@{z.index}FInverse[Id, @{tpes.tpeParams}, A] } else { Inj.instance((lifta@{z.index}@{F}Inverse[@{F}, @{tpes.tpeParams}].apply _).andThen(i.apply _)) }
    }
