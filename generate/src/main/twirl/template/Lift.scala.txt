@import andxor.syntax._
@import scalaz.Zipper
@import scalaz.syntax.std.boolean._

@(z: Zipper[String], isId: Boolean)

@prodAccesses(l: List[String], i: Int) = @{ l.zip(Stream.from(i)).map(t => s"t${z.toList.prodAccess(t._2 + 1)}") }
@tpes = @{ z.toList }
@F = @{ isId.fold("Id", "F") }
@tp = @{ isId.fold("", s"F[_], ") }
@monoid(others: Boolean, ts: List[String] = tpes) = @{
  ts.foldLen01("")(others.fold[String => String](x => s", $x", x => s"(implicit $x)")(s" M: Monoid[${ts.prodTpeF(F)}]"))
}

implicit def lifta@{z.index}@{F}[@{tp}@{tpes.rank2TpeParams}]@{monoid(false)}: FInj[@tpes.prodTpeF("?[_]"), @{tpes(z.index)}, @F] =
  @if(isId) {
    lifta@{z.index}F[Id, @{tpes.tpeParams}]
  } else { {
    @tpes.foldLen01("")("val t = M.zero\n      ")Inj.instance(x => @{tpes.prodTpeF(F)}(@{((prodAccesses(z.lefts.toList, 0) :+ "x") ++
      prodAccesses(z.rights.toList, z.lefts.toList.length + 1)).mkTuple}))
  } }
