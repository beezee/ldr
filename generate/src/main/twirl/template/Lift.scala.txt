@import andxor.syntax._
@import scalaz.Zipper
@import scalaz.syntax.std.boolean._

@(z: Zipper[String], isId: Boolean)

@tupleAccesses(l: List[String], i: Int) = @{ l.zip(Stream.from(i)).map(t => s"t${z.toList.tupleAccess(t._2 + 1)}") }
@tpes = @{ z.toList }
@F = @{ isId.fold("Id", "F") }
@tp = @{ isId.fold("", s"F[_], ") }
@wrapTpe(s: String) = @{ isId.fold(s, s"F[$s]") }

    implicit def lifta@{z.index}@{F}[@{tp}@{tpes.tpeParams}]@{tpes.foldLen01("")(s"(implicit M: Monoid[${tpes.prodTpeF(F)}])")}: Inj[@tpes.prodTpeF(F), @{wrapTpe(z.focus)}] =@if(isId) { lifta@{z.index}F[Id, @{tpes.tpeParams}] } else { {
      @tpes.foldLen01("")("val t = M.zero.run\n      ")Inj.instance(x => @{tpes.prodTpeF(F)}(@{((tupleAccesses(z.lefts.toList, 0) :+ "x") ++
        tupleAccesses(z.rights.toList, z.lefts.toList.length + 1)).mkTuple}))
    }
    }

    implicit def lifta@{z.index}@{F}Inverse[@{tp}@{tpes.tpeParams}]: Inj[@{wrapTpe(z.focus)}, @tpes.prodTpeF(F)] =@if(isId) { lifta@{z.index}FInverse[Id, @{tpes.tpeParams}] } else { Inj.instance(_.run@{z.toList.tupleAccess(z.index + 1)}) }
