@import andxor.syntax._
@import scalaz.Zipper
@import scalaz.syntax.std.boolean._

@(z: Zipper[String], isId: Boolean)

@prodAccesses(l: List[String], i: Int) = @{ l.zip(Stream.from(i)).map(t => s"t${z.toList.prodAccess(t._2 + 1)}") }
@tpes = @{ z.toList }
@F = @{ isId.fold("Id", "F") }
@monoid(others: Boolean, ts: List[String] = tpes) = @{
  ts.foldLen01("")(others.fold[String => String](x => s", $x", x => s"(implicit $x)")(s" M: Monoid[${ts.prodTpeF(F)}]"))
}

@if(isId) {
  implicit def lifta@{z.index}Id[A, @{tpes.rank2TpeParams}](implicit ev: @{tpes(z.index)}[Id] === A@{monoid(true)}): Inj[@{tpes.prodTpeF("Id")}, A] =
    ev.subst(lifta@{z.index}F[Id, @{tpes.tpeParams}])
} else {
  implicit def lifta@{z.index}F[F[_], @{tpes.rank2TpeParams}]@{monoid(false)}: FInj[@tpes.prodTpeF("?[_]"), @{tpes(z.index)}, F] = {
    @tpes.foldLen01("")("val t = M.zero\n      ")Inj.instance(x => @{tpes.prodTpeF(F)}(@{((prodAccesses(z.lefts.toList, 0) :+ "x") ++
      prodAccesses(z.rights.toList, z.lefts.toList.length + 1)).mkTuple}))
  }
}
