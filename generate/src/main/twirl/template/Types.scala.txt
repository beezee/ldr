@import andxor.syntax._

@(tpeLists: List[List[String]])

import andxor.Sequence.syntax._
import andxor.Transform.syntax._
import scalaz.{\/, -\/, \/-, ~>, Apply, Functor, InvariantFunctor, Monoid}
import scalaz.Id.Id

object types {
  object dummy {
    @tpeLists.map(_.length).map { i =>
    sealed trait Dummy@{i}; object Dummy@{i} { implicit val inst: Dummy@{i} = new Dummy@{i} {} }}
  }

  import dummy._

  private val MF = InvariantFunctor[Monoid]
  @tpeLists.map { tpes =>
  @@newtype case class @{tpes.prodTpeDef}(run: @{tpes.prodK("F")}) { self =>
    @template.txt.TupleAccess("run", tpes.prodTpes())

    @if(tpes.length > 1) {
    private def mapN = new Map@{tpes.length}P[@{tpes.selCopOrProd("Prod", Some("F")).tpeParams}] {}
    @{tpes.zipper(template.txt.MapNPOp(_, true)).mkString("\n")}
    }
  }

  trait @{tpes.prodName}LP {
    @if(tpes.length == 1) { implicit def conv[F[_], A](a: F[A]): Prod1[F, A] = Prod1[F, A](a) }

    implicit def @{tpes.prodName}Transform[@{tpes.axoTpeParams}]@{tpes.transformParams("Prod").asImpls(false)}: Transform[@{tpes.prodTpeF("?[_]")}] =
      new Transform[@{tpes.prodTpeF("?[_]")}] {
        def transform[F[_], G[_]](nt: F ~> G): @tpes.prodTpe => @tpes.prodTpeF("G") =
          p => @{tpes.prodTpeF("G")}(@{tpes.paramListF(i =>
            tpes.foldLen01("nt")(s"trans$i.transform(nt)") ++ s"(p${tpes.prodAccess(i + 1)})").mkTuple})
      }

    implicit def @{tpes.prodName}Sequence[@{tpes.axoTpeParams}]@{tpes.sequenceParams("Prod").asImpls(false)}: Sequence[@{tpes.prodTpeF("?[_]")}, Apply] =
      new Sequence[@{tpes.prodTpeF("?[_]")}, Apply] {
        def sequence[F[_]](p: @{tpes.prodTpeF("F")})(implicit F: Apply[F]): F[@{tpes.prodTpeF("Id")}] =
          @tpes.paramListF(i => s"seq$i.sequence(p${tpes.prodAccess(i + 1)})").tail.foldLeft(
            s"F.map(${tpes.foldLen01(s"p${tpes.prodAccess(1)}")(s"seq0.sequence[F](p${tpes.prodAccess(1)})")})(${tpes.prodTpes("Id").paramSigArgs("i")
              .map(parens).mkString(" => ")} => ${tpes.prodTpeF("Id")}(${tpes.paramList("i").mkTuple}))")(
                (a, e) => s"F.ap($e)($a)")
      }

    implicit def @{tpes.prodName}FoldMap[@{tpes.axoTpeParams}]@{tpes.foldMapParams.asImpls(false)}: FoldMap[@{tpes.prodTpeF("?[_]")}, @{tpes.copTpeF("?[_]")}] =
      new FoldMap[@{tpes.prodTpeF("?[_]")}, @{tpes.copTpeF("?[_]")}] {
        def unconsAll[F[_], G[_]](p: @{tpes.prodTpe})(implicit U: Uncons[F, G]): (List[@{tpes.copTpeF("G")}], @{tpes.prodTpe}) = {
          @{1.to(tpes.length).toList.map(i => s"val (h$i, t$i) = ${tpes.foldLen01("U")(s"${tpes.foldMapName(i - 1)}.unconsAll")}(p${tpes.prodAccess(i)})").mkString("\n      ")}
          (List(@{1.to(tpes.length).toList.map(i => s"h$i.map(Inj[${tpes.copTpeF("G")}, ${tpes.selCop(Some("G"))(i - 1)}].apply(_))").mkString(", ")}).flatten,
            @{tpes.prodTpe}(@{1.to(tpes.length).toList.map(i => s"t$i").mkTuple}))
        }

        def unconsOne[F[_], G[_]](p: @{tpes.prodTpe}, c: @{tpes.copTpeF("G")})(implicit U: Uncons[F, G]): (Option[@{tpes.copTpeF("G")}], @{tpes.prodTpe}) =
          c.run match {
            @{tpes.zipper(FoldMap(_)).mkString("").dropWhile(_ == ' ')}
          }
      }

    implicit def @{tpes.prodName}DerivingProd[TC[_], F[_], @{tpes.axoTpeParams}]@{tpes.derivingParams("Prod", "TC", "F").asImpls(false)}: DerivingProd[@{tpes.prodTpeF("?[_]")}, F, TC] =
      new DerivingProd[@{tpes.prodTpeF("?[_]")}, F, TC] {
        def mkContravariant[A](f: A => @{tpes.prodTpe})(implicit D: Divide[TC]): TC[A] =
          @tpes.foldLen01("D.contramap(tc)(f(_).run)")(s"Combine.divide${tpes.length}(${
            tpes.paramListF(i => s"deriving$i.divide").mkString(", ")})(f(_).run)")


        def mkCovariant[A](f: @{tpes.prodTpe} => A)(implicit A: Apply[TC]): TC[A] =
          @tpes.foldLen01[Any](s"A.map(tc)(x => f(${tpes.prodTpe}(x)))") {
          Combine.apply@{tpes.length}(@{tpes.paramListF(i => s"deriving$i.apply").mkString(", ")}) {
            case @{tpes.paramList("i").mkTuple} =>
              f(@{tpes.prodTpe}(@{tpes.paramList("i").mkTuple}))
          }
          }
      }

    implicit def @{tpes.prodName}Monoid[F[_], @{tpes.axoTpeParams}](implicit M: Monoid[@{tpes.prodK("F")}]): Monoid[@{tpes.prodTpe}] =
      MF.xmap(M, @{tpes.prodTpe}(_: @{tpes.prodK("F")}), (_: @{tpes.prodTpe}).run)

    @tpes.zipper(template.txt.Lift(_, false).toString.trim).mkString("\n\n    ")
  }

  object @{tpes.prodName} extends @{tpes.prodName}LP {
    @if(tpes.length == 1) { implicit def convId[A](a: A): Prod1[Id, A] = Prod1[Id, A](a) }

    @tpes.zipper(template.txt.Lift(_, true).toString.trim).mkString("\n\n    ")
  }

  @@newtype case class @{tpes.copTpeDef}(run: @{tpes.djK("F")})

  @*@{(tpes.length <= 1).fold("", s""" {
    private def mapN = new Map${tpes.length}C[${tpes.tpeParamsF("F")}] {}
    ${tpes.zipper(template.txt.MapNCOp(_, true)).mkString("\n")}
  }""")}*@

  trait @{tpes.copName}LP {
    @if(tpes.length == 1) { implicit def conv[F[_], A](a: F[A]): Cop1[F, A] = Cop1[F, A](a) }

    implicit def @{tpes.copName}Transform[@{tpes.axoTpeParams}]@{tpes.transformParams("Cop").asImpls(false)}: Transform[@{tpes.copTpeF("?[_]")}] =
      new Transform[@{tpes.copTpeF("?[_]")}] {
        def transform[F[_], G[_]](nt: F ~> G): @tpes.copTpeF("F") => @tpes.copTpeF("G") =
          c => @{tpes.copTpeF("G")}(@{tpes.foldLen01("nt(c.run)")(
            s"c.run${tpes.tail.foldRight("_.transform(nt)")((_, a) => s"_.bimap(_.transform(nt), $a)").tail}")})
      }

    implicit def @{tpes.copName}Sequence[@{tpes.axoTpeParams}]@{tpes.sequenceParams("Cop").asImpls(false)}: Sequence[@{tpes.copTpeF("?[_]")}, Functor] =
      new Sequence[@{tpes.copTpeF("?[_]")}, Functor] {
        def sequence[F[_]](c: @{tpes.copTpeF("F")})(implicit F: Functor[F]): F[@{tpes.copTpeF("Id")}] =
          c.run match {
            @{tpes.zipper(SequenceC(_)).mkString("        ").trim}
          }
      }

    implicit def @{tpes.copName}DerivingCop[TC[_], F[_], @{tpes.axoTpeParams}]@{tpes.derivingParams("Cop", "TC", "F").asImpls(false)}: DerivingCop[@{tpes.copTpeF("?[_]")}, F, TC] =
      new DerivingCop[@{tpes.copTpeF("?[_]")}, F, TC] {
        def mkCovariant[A](f: @{tpes.copTpe} => A)(implicit A: Alt[TC]): TC[A] =
          @tpes.foldLen01(s"A.map(tc)(x => f(${tpes.copTpe}(x)))")(s"Combine.altly${tpes.length}(${
            tpes.paramListF(i => s"deriving$i.alt").mkString(", ")})(x => f(${tpes.copTpe}(x)))")

        def mkContravariant[A](f: A => @{tpes.copTpe})(implicit D: Decidable[TC]): TC[A] =
          @tpes.foldLen01("D.contramap(tc)(f(_).run)")(s"Combine.choose${tpes.length}(${
            tpes.paramListF(i => s"deriving$i.choose").mkString(", ")})(f(_).run)")
      }

    @tpes.zipper(template.txt.Inj(_, false).toString.trim).mkString("\n\n    ")
  }

  object @{tpes.copName} extends @{tpes.copName}LP {
    @if(tpes.length == 1) { implicit def convId[A](a: A): Cop1[Id, A] = Cop1[Id, A](a) }

    @tpes.zipper(template.txt.Inj(_, true).toString.trim).mkString("\n\n    ")
  }
  }
}
