@import andxor.syntax._

@(tpeLists: List[List[String]])

import andxor.Sequence.ops._
import andxor.tuple._
import andxor.Transform.ops._
import scalaz.{\/, -\/, \/-, ~>, Apply, Functor, InvariantFunctor, Monoid}
import scalaz.Id.Id

object types {
  object dummy {
    @tpeLists.map(_.length).map { i =>
    sealed trait Dummy@{i}; object Dummy@{i} { implicit val inst: Dummy@{i} = new Dummy@{i} {} }}
  }

  // import dummy._

  private val MF = InvariantFunctor[Monoid]
  @tpeLists.map { tpes =>
  @@newtype case class @{tpes.prodTpeDef}(run: @{tpes.prodK("F")}) {
    @template.txt.TupleAccess("run", tpes.prodTpes())

    @*
    @if(tpes.length > 1) {
    private def mapN = new Map@{tpes.length}P[@{tpes.tpeParamsF("F")}] {}
    @{tpes.zipper(template.txt.MapNPOp(_, true)).mkString("\n")}
    }
    *@
  }

  trait @{tpes.prodName}LP {
    implicit def @{tpes.prodName}Transform[@{tpes.axoTpeParams}]@{tpes.transformParams("Prod").asImpls(false)}: Transform[@{tpes.prodTpeF("?[_]")}] =
      new Transform[@{tpes.prodTpeF("?[_]")}] {
        def transform[F[_], G[_]](nt: F ~> G): @tpes.prodTpe => @tpes.prodTpeF("G") =
          p => @{tpes.prodTpeF("G")}(@{tpes.paramListF(i =>
            tpes.foldLen01("nt")(s"trans$i.transform(nt)") ++ s"(p${tpes.prodAccess(i + 1)})").mkTuple})
      }

    implicit def @{tpes.prodName}Sequence[@{tpes.axoTpeParams}]@{tpes.sequenceParams("Prod").asImpls(false)}: Sequence[@{tpes.prodTpeF("?[_]")}, Apply] =
      new Sequence[@{tpes.prodTpeF("?[_]")}, Apply] {
        def sequence[F[_]](p: @{tpes.prodTpeF("F")})(implicit F: Apply[F]): F[@{tpes.prodTpeF("Id")}] =
          @tpes.paramListF(i => s"seq$i.sequence(p${tpes.prodAccess(i + 1)})").tail.foldLeft(
            s"F.map(${tpes.foldLen01(s"p${tpes.prodAccess(1)}")(s"seq0.sequence[F](p${tpes.prodAccess(1)})")})(${tpes.prodTpes("Id").paramSigArgs("i")
              .map(parens).mkString(" => ")} => ${tpes.prodTpeF("Id")}(${tpes.paramList("i").mkTuple}))")(
                (a, e) => s"F.ap($e)($a)")
      }

    implicit def @{tpes.prodName}FoldMap[@{tpes.axoTpeParams}]@{tpes.foldMapParams.asImpls(false)}: FoldMap[@{tpes.prodTpeF("?[_]")}, @{tpes.copTpeF("?[_]")}] =
      new FoldMap[@{tpes.prodTpeF("?[_]")}, @{tpes.copTpeF("?[_]")}] {
        def unconsAll[F[_]](p: @{tpes.prodTpe})(implicit U: Uncons[F]): (List[@{tpes.copTpeF("Id")}], @{tpes.prodTpe}) = {
          @{1.to(tpes.length).toList.map(i => s"val (h$i, t$i) = ${tpes.foldLen01("U")(s"${tpes.foldMapName(i - 1)}.unconsAll")}(p${tpes.prodAccess(i)})").mkString("\n      ")}
          (List(@{1.to(tpes.length).toList.map(i => s"h$i.map(Inj[${tpes.copTpeF("Id")}, ${tpes.selCop(Some("Id"))(i - 1)}].apply(_))").mkString(", ")}).flatten,
            @{tpes.prodTpe}(@{1.to(tpes.length).toList.map(i => s"t$i").mkTuple}))
        }

        def unconsOne[F[_]](p: @{tpes.prodTpe}, c: @{tpes.copTpeF("Id")})(implicit U: Uncons[F]): (Option[@{tpes.copTpeF("Id")}], @{tpes.prodTpe}) =
          c.run match {
            @{tpes.zipper(FoldMap(_)).mkString("").dropWhile(_ == ' ')}
          }
      }

    implicit def @{tpes.prodName}Monoid[F[_], @{tpes.axoTpeParams}](implicit M: Monoid[@{tpes.prodK("F")}]): Monoid[@{tpes.prodTpe}] =
      MF.xmap(M, @{tpes.prodTpe}(_: @{tpes.prodK("F")}), (_: @{tpes.prodTpe}).run)

    @tpes.zipper(template.txt.Lift(_, false).toString.trim).mkString("\n\n    ")
  }

  object @{tpes.prodName} extends @{tpes.prodName}LP {
    @tpes.zipper(template.txt.Lift(_, true).toString.trim).mkString("\n\n    ")
  }

  @@newtype case class @{tpes.copTpeDef}(run: @{tpes.djK("F")})

  @*@{(tpes.length <= 1).fold("", s""" {
    private def mapN = new Map${tpes.length}C[${tpes.tpeParamsF("F")}] {}
    ${tpes.zipper(template.txt.MapNCOp(_, true)).mkString("\n")}
  }""")}*@

  trait @{tpes.copName}LP {
    implicit def @{tpes.copName}Transform[@{tpes.axoTpeParams}]@{tpes.transformParams("Cop").asImpls(false)}: Transform[@{tpes.copTpeF("?[_]")}] =
      new Transform[@{tpes.copTpeF("?[_]")}] {
        def transform[F[_], G[_]](nt: F ~> G): @tpes.copTpeF("F") => @tpes.copTpeF("G") =
          c => @{tpes.copTpeF("G")}(@{tpes.foldLen01("nt(c.run)")(
            s"c.run${tpes.tail.foldRight("_.transform(nt)")((_, a) => s"_.bimap(_.transform(nt), $a)").tail}")})
      }

    implicit def @{tpes.copName}Sequence[@{tpes.axoTpeParams}]@{tpes.sequenceParams("Cop").asImpls(false)}: Sequence[@{tpes.copTpeF("?[_]")}, Functor] =
      new Sequence[@{tpes.copTpeF("?[_]")}, Functor] {
        def sequence[F[_]](c: @{tpes.copTpeF("F")})(implicit F: Functor[F]): F[@{tpes.copTpeF("Id")}] =
          c.run match {
            @{tpes.zipper(SequenceC(_)).mkString("        ").trim}
          }
      }

    @tpes.zipper(template.txt.Inj(_, false).toString.trim).mkString("\n\n    ")
  }

  object @{tpes.copName} extends @{tpes.copName}LP {
    @tpes.zipper(template.txt.Inj(_, true).toString.trim).mkString("\n\n    ")
  }
  }
}
